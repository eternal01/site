---
title: "Mysql"
date: 2022-10-16T10:27:37Z
# bookComments: false
# bookSearchExclude: false
---

## **Mysql 索引结构**
使用二叉树查询的时候，查询的时间复杂度是O(log n)，查询的时间效率已经很快。但是二叉树存在一个问题是，每一个分支上，最多就只有两个分支，当数据量大的时候，就会导致树的高度很高，查询的时候，IO的次数就会增多，查询的效率就会有所下降。使用B树或者B+树，让一个节点，可以有多个分支，可以很好的降低树的高度，减少IO的次数，提升查询的效率。
- B树的特点是每一个节点中都会存储key和数据，而B+树只有叶子节点才会存储数据信息（这里的数据信息 指 索引的数据信息。针对聚簇索引），其他的节点都只会存储key的信息。Mysql在查询的时候，因为其他节点的数据量少，可以一次性的在内存中加载更多的key的数据，以供查询使用。
- B树的叶子节点之间是独立的，B+树的叶子节点之间有指针将叶子节点相连接起来。Mysql是一种关系型数据库，多个数据之间可能是存在一定的关系的，当查询某一个数据的时候，可能会查询和之相关的一些其他的数据，可以很好的支持范围查询。
- B树的查询效率不稳定，B+树查询的效率稳定。当查询数据的时候，B树在遇到满足条件的数据之后，就会返回数据信息，不会走到叶子节点。但是B+树在查询的时候，无论如何都会走到叶子节点，才会获取到数据，并返回数据信息。
- 因为B+树的叶子节点不会存放数据信息（这里的数据信息指 完整的数据信息，包括了未添加索引的列的信息。即 索引中的 叶子节点，只会存放 索引列的数据，不包括未被索引的数据。聚簇索引包括所有数据，其他索引只包括 索引列和主键列），所以有更多的空间来存放key的信息，可以让树的高度更低，IO的次数更少，效率更高。

## **Mysql 索引类型，有何区别？**
- 主键索引
- 唯一索引
- 普通索引
- 组合索引
- 全文索引

    - 聚簇索引：索引和数据处于同一个树结构中，叶子结点存储完整的数据。Innodb 使用聚簇索引
    - 非聚簇索引：索引和数据不处于同一个树结构中，叶子结点存储的是指向数据的指针或地址信息，想获取完整数据需进行回表。MyIsam 使用非聚簇索引

## **Mysql 优化**

    - explain 查看sql执行计划
    - explain extended    会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。
    - explain partitions  相比 explain 多了个 partitions 字段。

### **id**
select的序列号，随select出现的顺序递增。id越大执行优先级越高；id相同则从上往下执行；id为null最后执行
### **select_type**
sql查询类型，简单查询or复杂查询
|字段值|描述|
|:---|:---|
|simple|简单查询|
|primary|复杂查询最外层的select|
|sbuquery|包含在select中的子查询（不在from子句中）|
|derived|包含在from子句中的子查询|
|union|在union中第二个及以后的select|
|union result|从 union 临时表检索结果的 select|
### **table**
sql访问的表
### **type**
访问类型

效率从高到低：null > system > const > eq_ref > ref > ref_or_null > index_merge > range > index > all

    常量表
    1. 表中没有数据，或者只有一行数据（system类表）
    2. 经where语句中的限制条件（"column=常数"格式的表达式）筛选后只有一行数据；这表明，在column列上存在索引，索引列可能是一个主键列，或者是唯一键的列（constant表），满足这2个条件之一的，就是常量表。

|字段值|描述|
|:---|:---|
|null|mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引|
|system|表内只有一条数据，const的特殊类型|
|const|索引一次就找到数据，const用于比较primary key或unique索引，因为只匹配一行数据，所以很快，如主键置于where列表中，MySQL就能将该查询转换为一个常量|
|eq_ref|唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描|
|ref|非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，返回所有匹配某个单独值的行，然而可能会找到多个符合条件的行，属于查找和扫描的混合体|
|ref_or_null|类似ref，但是可以搜索值为NULL的行|
|index_merge|表示使用了索引合并的优化方法|
|range|只检索给定范围的行，使用一个索引来选择行|
|index|索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询|
|all|全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录|

### **possible_keys**
可能使用的索引
### **key**
实际使用的索引
### **key_len**
在索引中使用的字节数
### **ref**
key列记录的索引中，表查找值所用的列或常量，值为const或列名
### **rows**
预估需要读取或检测的行数
### **extra**
额外信息
|字段值|描述|
|:---|:---|
|using index|查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高|
|using where|查询的列未被索引覆盖，where筛选条件非索引的前导列|
|using where using index|查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据|
|null|查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引|
|using index condition|与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围|
|using temporary|mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化|
|using filesort|mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行|

### **filtered**
filtered 列，是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）
### **partitions**
如果查询是基于分区表的话，会显示查询将访问的分区。

## **Mysql 索引失效**
- 索引列上进行操作
    - 类型转换
    - 计算
- like 查询以%开头
- 不满足最左前缀原则
- or 查询
- null列
- != 判断
- 查询条件发生隐式转换
- 估计全表扫描比索引快

## **Mysql 索引下推**
如果查询语句中的所有的查询条件均是在索引中存在的，则Mysql服务器会把查询条件下推到存储引擎中，存储引擎判断如果满足条件就会直接返回数据，如果不满足，则继续下一条数据。

如果查询条件中的部分条件不是索引中的列数据信息，则存储引擎在满足索引条件之后，就会返回数据，然后Mysql服务器再去获取整个数据，然后判断数据是否满足，满足则需要，否则抛弃数据。

使用索引下推在一定程度上可以减少IO的次数，因为返回的数据均是满足条件的数据，Mysql服务器不用再去获取一次数据判断。

## **Mysql 索引合并**
当我们进行数据查询的时候，我们的where 语句中可能存在有多个查询条件，可能会走到多个索引。Mysql 5.1 之前只会选择其中一个索引进行数据查询，然后交给Mysql服务器去做数据过滤。5.1之后引入的索引合并（Index merge）技术，支持通过多个索引去查询数据，然后对结果进行计算。

- Index-Intersection
- Index-Union
- Index-Sort-Union

## **Mysql 高可用**
### **主从复制**
    利用binlog实现

    master节点
    1. 启用二进制日志
    2. 为当前节点设置全局唯一ID号
    3. 重启数据库
    4. 查看从二进制日志的文件和位置开始进行复制
    5. 创建有复制权限的用户账号 
    slave节点
    1. 启用中继日志
    2. 使用有复制权限的用户账号连接至主服务器，并启动复制线程

## **Mysql 日志的录入格式，有何区别？**
- statement 每一条会修改数据的SQL都会记录在binlog中，不需要记录每一行的变化，减少了binlog的日志量，节约了IO，提高了性能，由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
- row   不记录SQL语句上下文相关操作，仅保存哪条记录被修改。记录单元为每一行的改动，基本可以记录下所有变动，但由于很多操作会导致大量行的变动（如：alert table），因此这种模式的文件保存的信息太多，日志量太大，会降低性能
- mixed 一种折衷方案，普通操作记录statement记录，当无法使用statement记录时使用row记录
