---
title: "Mysql"
date: 2022-10-16T10:27:37Z
# bookComments: false
# bookSearchExclude: false
---

## **关系型数据库和非关系型数据库（NoSQL）的区别**
关系型数据库优点：
- 使用关系模型来组织数据，容易理解
- 可以保持数据的一致性
- 数据更新的开销较小
- 支持复杂查询

非关系型数据库优点：
- 无需经过SQL层的解析，读写效率高
- 基于键值对，读写性能高，易于拓展
- 可以支持多种类型数据的存储，图片、文档等
- 扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）

## **DCL、DDL、DML**
- DCL(DATA CONTROL LANGUAGE) 操作数据库用户、权限等
- DDL(DATA DEFINITION LANGUAGE) 操作数据库、表结构、数据类型、表间约束等
- DML(DATA MANIPULITION LANGUAGE) 操作数据库数据，增删改查等

## **Mysql 语句执行过程**
1. 客户端请求 ---> 连接器（验证用户身份，给予权限）
2. 查询缓存（存在缓存则直接返回，不存在则继续下一步操作）
3. 分析器（对sql进行语法分析等操作）
4. 优化器（对执行的sql优化，选择最优的优化方案执行）
5. 执行器（执行时会先查看用户是否拥有执行权限，调用存储引擎提供的接口） ---> 存储引擎（若开启查询缓存会缓存查询结果）

## **Mysql 使用索引的原因**
- 提高数据查询效率

## **索引的三种常见数据结构和优缺点**
    三种常见的索引数据结构为哈希表、有序数组和搜索树

- 哈希表这种数据结构适用于等值查询，不适合范围查询。常用于NoSQL存储引擎。
- 有序数组只适用于静态存储引擎，等值查询和范围查询性能好，但更新数据成本高
- 搜索树（N叉树）由于读写性能上的优点以及适配磁盘访问模式，广泛用于关系型数据库存储引擎中

## **Mysql 索引结构**
使用二叉树查询的时候，查询的时间复杂度是O(log n)，查询的时间效率已经很快。但是二叉树存在一个问题是，每一个分支上，最多就只有两个分支，当数据量大的时候，就会导致树的高度很高，查询的时候，IO的次数就会增多，查询的效率就会有所下降。使用B树或者B+树，让一个节点，可以有多个分支，可以很好的降低树的高度，减少IO的次数，提升查询的效率。
- B树的特点是每一个节点中都会存储key和数据，而B+树只有叶子节点才会存储数据信息（这里的数据信息 指 索引的数据信息。针对聚簇索引），其他的节点都只会存储key的信息。Mysql在查询的时候，因为其他节点的数据量少，可以一次性的在内存中加载更多的key的数据，以供查询使用。
- B树的叶子节点之间是独立的，B+树的叶子节点之间有指针将叶子节点相连接起来。Mysql是一种关系型数据库，多个数据之间可能是存在一定的关系的，当查询某一个数据的时候，可能会查询和之相关的一些其他的数据，可以很好的支持范围查询。
- B树的查询效率不稳定，B+树查询的效率稳定。当查询数据的时候，B树在遇到满足条件的数据之后，就会返回数据信息，不会走到叶子节点。但是B+树在查询的时候，无论如何都会走到叶子节点，才会获取到数据，并返回数据信息。
- 因为B+树的叶子节点不会存放数据信息（这里的数据信息指 完整的数据信息，包括了未添加索引的列的信息。即 索引中的 叶子节点，只会存放 索引列的数据，不包括未被索引的数据。聚簇索引包括所有数据，其他索引只包括 索引列和主键列），所以有更多的空间来存放key的信息，可以让树的高度更低，IO的次数更少，效率更高。

## **Mysql 索引类型，有何区别？**
- 主键索引
- 唯一索引
- 普通索引
- 组合索引
- 全文索引

    - 聚簇索引：索引和数据处于同一个树结构中，叶子结点存储完整的数据。Innodb 使用聚簇索引
    - 非聚簇索引：索引和数据不处于同一个树结构中，叶子结点存储的是指向数据的指针或地址信息，想获取完整数据需进行回表。MyIsam 使用非聚簇索引

## **Mysql 优化**

    - explain 查看sql执行计划
    - explain extended    会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。
    - explain partitions  相比 explain 多了个 partitions 字段。

### **id**
select的序列号，随select出现的顺序递增。id越大执行优先级越高；id相同则从上往下执行；id为null为其他查询的聚合结果
### **select_type**
sql查询类型，简单查询or复杂查询
|字段值|描述|
|:---|:---|
|simple|简单查询|
|primary|复杂查询最外层的select|
|subquery|包含在select中的子查询（不在from子句中）|
|derived|包含在from子句中的子查询|
|union|在union中第二个及以后的select|
|union result|从 union 临时表检索结果的 select|
|dependent union|顾名思义，第二个及之后的 union select|
|dependent subquery|顾名思义，第二个及之后的子查询的select|
### **table**
sql访问的表
### **type**
访问类型

效率从高到低：null > system > const > eq_ref > ref > ref_or_null > index_merge > range > index > all

    常量表
    1. 表中没有数据，或者只有一行数据（system类表）
    2. 经where语句中的限制条件（"column=常数"格式的表达式）筛选后只有一行数据；这表明，在column列上存在索引，索引列可能是一个主键列，或者是唯一键的列（constant表），满足这2个条件之一的，就是常量表。

|字段值|描述|
|:---|:---|
|null|mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引|
|system|表内只有一条数据，const的特殊类型|
|const|索引一次就找到数据，const用于比较primary key或unique索引，因为只匹配一行数据，所以很快，如主键置于where列表中，MySQL就能将该查询转换为一个常量|
|eq_ref|唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描|
|ref|非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，返回所有匹配某个单独值的行，然而可能会找到多个符合条件的行，属于查找和扫描的混合体|
|ref_or_null|类似ref，但是可以搜索值为NULL的行|
|index_merge|表示使用了索引合并的优化方法|
|range|只检索给定范围的行，使用一个索引来选择行|
|index|索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询|
|all|全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录|

### **possible_keys**
可能使用的索引
### **key**
实际使用的索引
### **key_len**
在索引中使用的字节数
### **ref**
key列记录的索引中，表查找值所用的列或常量，值为const或列名
### **rows**
预估需要读取或检测的行数
### **extra**
额外信息
|字段值|描述|
|:---|:---|
|using index|查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高|
|using where|查询的列未被索引覆盖，where筛选条件非索引的前导列|
|using where using index|查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据|
|null|查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引|
|using index condition|与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围|
|using temporary|mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化|
|using filesort|mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行|

### **filtered**
filtered 列，是一个百分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）
### **partitions**
如果查询是基于分区表的话，会显示查询将访问的分区。

## **Mysql 索引失效**
- 索引列上进行操作
    - 类型转换
    - 计算
- like 查询以%开头
- 不满足最左前缀原则
- or 查询列中存在非索引列
- != 判断
- 查询条件发生隐式转换
- 估计全表扫描比索引快

    null列会降低查询效率

## **Mysql 索引下推**
如果查询语句中的所有的查询条件均是在索引中存在的，则Mysql服务器会把查询条件下推到存储引擎中，存储引擎判断如果满足条件就会直接返回数据，如果不满足，则继续下一条数据。

如果查询条件中的部分条件不是索引中的列数据信息，则存储引擎在满足索引条件之后，就会返回数据，然后Mysql服务器再去获取整个数据，然后判断数据是否满足，满足则需要，否则抛弃数据。

使用索引下推在一定程度上可以减少IO的次数，因为返回的数据均是满足条件的数据，Mysql服务器不用再去获取一次数据判断。

## **Mysql 索引合并**
当我们进行数据查询的时候，我们的where 语句中可能存在有多个查询条件，可能会走到多个索引。Mysql 5.1 之前只会选择其中一个索引进行数据查询，然后交给Mysql服务器去做数据过滤。5.1之后引入的索引合并（Index merge）技术，支持通过多个索引去查询数据，然后对结果进行计算。

- Index-Intersection
- Index-Union
- Index-Sort-Union

## **Mysql change buffer**
    当需要更新一个数据页时，如果数据页在内存中则直接更新；而如果这个数据页不在内存中，在不影响数据一致性的前提下，Innodb会将这些更新操作缓存在change buffer中

    在下次读取该数据页时，将数据页读入内存，再执行change buffer中与这个页相关的操作。通过这种方式保证数据逻辑的正确性

    唯一索引的更新不能使用change buffer,只有普通索引可以使用该特性
    
    对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统

## **Mysql 高可用**
### **主从复制**
    利用binlog实现

    master节点
    1. 启用二进制日志
    2. 为当前节点设置全局唯一ID号
    3. 重启数据库
    4. 查看从二进制日志的文件和位置开始进行复制
    5. 创建有复制权限的用户账号 
    slave节点
    1. 启用中继日志
    2. 使用有复制权限的用户账号连接至主服务器，并启动复制线程

## **Mysql 两阶段提交**
执行器想要更新记录R ---> Innodb将记录R加载进Buffer Pool ---> 将记录R旧值写入undo log便于回滚 ---> 执行器更新内存中的数据（此时该数据页为脏页） ---> 执行器写redo log（prepare） ---> 执行器写binlog ---> 执行器写redo log（commit）

    在恢复数据时，redolog 状态为 commit 则说明 binlog 也成功，直接恢复数据；如果 redolog 是 prepare，则需要查询对应的 binlog事务是否成功，决定是回滚还是执行。

## **Mysql 日志的录入格式，有何区别？**
- statement 每一条会修改数据的SQL都会记录在binlog中，不需要记录每一行的变化，减少了binlog的日志量，节约了IO，提高了性能，由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
- row   不记录SQL语句上下文相关操作，仅保存哪条记录被修改。记录单元为每一行的改动，基本可以记录下所有变动，但由于很多操作会导致大量行的变动（如：alert table），因此这种模式的文件保存的信息太多，日志量太大，会降低性能
- mixed 一种折衷方案，普通操作记录statement记录，当无法使用statement记录时使用row记录

## **Mysql 事务特性**
    ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
    
- 原子性 事务中包含的操作要么全部成功，要么全部失败会滚
- 一致性 事务执行前后必须处于一致性状态
- 隔离性 多个并发事务之间要相互隔离，不相互影响
- 持久性 事务执行完成对数据库的更改是永久的

## **Mysql 隔离级别**
- 读未提交  （脏读、不可重复读、幻读）
- 读已提交  （不可重复读、幻读）
- 可重复读  （幻读）
- 串行化